// this source file expects trace.inc generated by a script
// trace.inc should define:
// 1. a macro NUM_PTRS representing maximum number of involved pointers
//    (because we are debugging the allocator, we should allocate
//    all our own data statically)
// 2. an entry function: void trace_main(void)
//    the trace replay code in trace_main() should call data_check()
//    declared below to verify the integrity of allocated data, and
//    several other functions when corresponding event happen

#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <assert.h>

// functions that should be invoked from trace_main()
void data_check(void); // entry function of checking whether all allocated objects are still intact
void objectAllocated(unsigned ptrIndex, uint64_t size, void* ptr);
void objectDeallocated(unsigned ptrIndex);
void objectMoved(unsigned originalPtrIndex, unsigned newPtrIndex, uint64_t size, void* ptr);

#include "trace.inc"

struct ObjectMetadata {
  void* ptr;
  uint64_t size;
  uint64_t seed;
};

static struct ObjectMetadata objects[NUM_PTRS];
static unsigned maxPtrIndex = 0;

static uint64_t getSeedForObject(void* ptr, uint64_t size)
{
  uint64_t seed = ((uint64_t)rand() << 48);
  seed = seed ^ ((uint64_t)rand() << 32);
  seed = seed ^ ((uint64_t)rand() << 16);
  seed = seed ^ ((uint64_t)rand());
  seed = seed ^ ((uint64_t)ptr) ^ (size << 4);
  return seed;
}

static unsigned char genChar(uint64_t* curSeedPtr)
{
  uint64_t seed = *curSeedPtr;
  unsigned char value = 0;
  for (unsigned i = 0; i < 8; ++i) {
    unsigned bit =
      ((seed >> 32) & 0x1) ^
      ((seed >> 26) & 0x1) ^
      ((seed >> 23) & 0x1) ^
      ((seed >> 22) & 0x1) ^
      ((seed >> 16) & 0x1) ^
      ((seed >> 12) & 0x1) ^
      ((seed >> 11) & 0x1) ^
      ((seed >> 10) & 0x1) ^
      ((seed >> 8) & 0x1) ^
      ((seed >> 7) & 0x1) ^
      ((seed >> 5) & 0x1) ^
      ((seed >> 4) & 0x1) ^
      ((seed >> 2) & 0x1) ^
      ( seed       & 0x1) ^
      0x1;
    value = (value << 1) | bit;
    seed = (seed >> 1) | (((uint64_t)bit) << 63);
  }
  *curSeedPtr = seed;
  return value;
}

static void fillObject(void* ptr, uint64_t size, uint64_t seed)
{
  uint64_t curSeed = seed;
  unsigned char* cptr = (unsigned char*)ptr;
  for (uint64_t i = 0; i < size; ++i) {
    unsigned char value = genChar(&curSeed);
    cptr[i] = value;
  }
}

static void checkObject(void* ptr, uint64_t size, uint64_t seed)
{
  uint64_t curSeed = seed;
  unsigned char* cptr = (unsigned char*)ptr;
  for (uint64_t i = 0; i < size; ++i) {
    unsigned char value = genChar(&curSeed);
    if (cptr[i] != value) {
      printf("Object corruption detected: at byte %lu: expecting 0x%x but get 0x%x\n", i, (unsigned)value, (unsigned)cptr[i]);
      assert(cptr[i] == value);
    }
  }
}

void objectAllocated(unsigned ptrIndex, uint64_t size, void* ptr)
{
  assert(objects[ptrIndex].ptr == NULL);
  objects[ptrIndex].ptr = ptr;
  objects[ptrIndex].size = size;
  uint64_t seed = getSeedForObject(ptr, size);
  objects[ptrIndex].seed = seed;
  fillObject(ptr, size, seed);
  if (maxPtrIndex < ptrIndex) {
    maxPtrIndex = ptrIndex;
  }
}

void objectDeallocated(unsigned ptrIndex)
{
  assert(objects[ptrIndex].ptr != NULL);
  objects[ptrIndex].ptr = NULL;
  objects[ptrIndex].size = 0;
  objects[ptrIndex].seed = 0;
  if (maxPtrIndex == ptrIndex) {
    while (maxPtrIndex > 0 && objects[maxPtrIndex].ptr == NULL) {
      maxPtrIndex -= 1;
    }
  }
}

void objectMoved(unsigned originalPtrIndex, unsigned newPtrIndex, uint64_t size, void* ptr)
{
  assert(objects[originalPtrIndex].ptr != NULL);
  
  // check if the original data is moved to the new memory region
  uint64_t smallerSize = objects[originalPtrIndex].size;
  if (smallerSize > size) {
    smallerSize = size;
  }
  checkObject(ptr, smallerSize, objects[originalPtrIndex].seed);
  
  // now the metadata update
  objectDeallocated(originalPtrIndex);
  objectAllocated(newPtrIndex, size, ptr);
}

void data_check(void)
{
  for (unsigned i = 0, n = maxPtrIndex; i <= n; ++i) {
    void* ptr = objects[i].ptr;
    if (ptr) {
      checkObject(ptr, objects[i].size, objects[i].seed);
    }
  }
}

int main(void)
{
  trace_main();
}
